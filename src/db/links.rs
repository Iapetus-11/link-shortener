use chrono::{DateTime, Utc};
use rand::distr::{Alphanumeric, SampleString};
use sqlx::PgConnection;
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct Link {
    pub slug: String,
    pub platform_id: Uuid,
    pub url: String,
    pub metadata: Option<serde_json::Value>,
    pub created_at: DateTime<Utc>,
}

/// Create a link in the database, a slug will be automatically generated if not provided
pub async fn create_link(
    db: &mut PgConnection,
    platform_id: &Uuid,
    mut slug: Option<String>,
    url: String,
    metadata: Option<serde_json::Value>,
) -> sqlx::Result<Link> {
    let mut result: Option<sqlx::Result<Link>> = None;

    let autogenerate_slug = slug.is_none();

    while match result {
        None => true,
        // Only retry if we're autogenerating a slug, otherwise it won't change and we'll have an infinite loop :)
        Some(Err(sqlx::Error::Database(ref db_err))) => {
            autogenerate_slug && db_err.is_unique_violation()
        }
        _ => false,
    } {
        if autogenerate_slug {
            slug = Some(
                Alphanumeric
                    .sample_string(&mut rand::rng(), 7) // TODO: Make the length configurable
                    .to_uppercase(),
            )
        }

        result = Some(
            sqlx::query_as!(
                Link,
                r#"
                    INSERT INTO links (slug, platform_id, url, metadata, created_at)
                    VALUES ($1, $2, $3, $4, NOW())
                    RETURNING slug, platform_id, url, metadata, created_at;
                "#,
                slug,
                platform_id,
                url,
                metadata,
            )
            .fetch_one(&mut *db)
            .await,
        );
    }

    result.unwrap()
}

/// Retrieve a link by its slug
pub async fn get_link(db: &mut PgConnection, slug: &str) -> sqlx::Result<Option<Link>> {
    sqlx::query_as!(
        Link,
        r#"
            SELECT slug, platform_id, url, metadata, created_at FROM links WHERE slug = $1
        "#,
        slug,
    )
    .fetch_optional(&mut *db)
    .await
}

pub async fn get_links(db: &mut PgConnection, platform_id: &Uuid) -> sqlx::Result<Vec<Link>> {
    sqlx::query_as!(
        Link,
        r#"
            SELECT
                slug, platform_id, url, metadata, created_at
            FROM links
            WHERE platform_id = $1
            ORDER BY created_at DESC;
        "#,
        platform_id,
    )
    .fetch_all(&mut *db)
    .await
}

/// Attempts to delete a link from the database, returning the deleted link or None if no link
/// for the specified slug exists
pub async fn delete_link(db: &mut PgConnection, link_slug: &str) -> sqlx::Result<Option<Link>> {
    sqlx::query_as!(
        Link,
        "DELETE FROM links WHERE slug = $1 RETURNING slug, platform_id, url, metadata, created_at;",
        link_slug
    )
    .fetch_optional(&mut *db)
    .await
}

#[cfg(test)]
mod tests {
    use serde_json::json;

    use super::*;
    use crate::{common::testing::db::PgPoolConn, db::platforms::create_platform};

    #[sqlx::test]
    async fn test_create_link_with_custom_slug(mut db: PgPoolConn) {
        let (_, platform) = create_platform(&mut db, "Test").await.unwrap();

        let link = create_link(
            &mut db,
            &platform.id,
            Some("custom_slug".to_string()),
            "https://iapetus11.me".to_string(),
            Some(json!({
                "w": 123,
            })),
        )
        .await
        .unwrap();

        assert_eq!(link.platform_id, platform.id);
        assert_eq!(link.slug, "custom_slug");
        assert_eq!(link.url, "https://iapetus11.me");
        assert_eq!(
            link.metadata
                .unwrap()
                .as_object()
                .unwrap()
                .get("w")
                .unwrap(),
            &serde_json::json!(123)
        );
    }

    #[sqlx::test]
    async fn test_create_link_with_autogenerated_slug(mut db: PgPoolConn) {
        let (_, platform) = create_platform(&mut db, "Test").await.unwrap();

        let link = create_link(
            &mut db,
            &platform.id,
            None,
            "https://iapetus11.me".to_string(),
            Some(json!({
                "w": 123,
            })),
        )
        .await
        .unwrap();

        assert_eq!(link.slug.len(), 7);
    }

    #[sqlx::test]
    async fn test_get_link(mut db: PgPoolConn) {
        let (_, platform) = create_platform(&mut db, "wowza").await.unwrap();

        let created_link = create_link(
            &mut db,
            &platform.id,
            None,
            "https://minecraft.global".to_string(),
            None,
        )
        .await
        .unwrap();

        let retrieved_link = get_link(&mut db, &created_link.slug)
            .await
            .unwrap()
            .unwrap();

        assert_eq!(created_link.slug, retrieved_link.slug);
        assert_eq!(created_link.platform_id, retrieved_link.platform_id);
        assert_eq!(created_link.url, retrieved_link.url);
        assert_eq!(created_link.metadata, retrieved_link.metadata);
        assert_eq!(created_link.created_at, retrieved_link.created_at);
    }

    #[sqlx::test]
    async fn test_get_links(mut db: PgPoolConn) {
        let (_, platform) = create_platform(&mut db, "wowza").await.unwrap();

        let link_a = create_link(
            &mut db,
            &platform.id,
            Some("link_a".to_string()),
            "https://www.kevinjosethomas.com/".to_string(),
            None,
        )
        .await
        .unwrap();

        let link_b = create_link(
            &mut db,
            &platform.id,
            Some("link_b".to_string()),
            "https://iapetus11.me/".to_string(),
            None,
        )
        .await
        .unwrap();

        let links = get_links(&mut db, &platform.id).await.unwrap();

        assert_eq!(links.len(), 2);
        assert_eq!(links[0].slug, link_b.slug);
        assert_eq!(links[1].slug, link_a.slug);
    }
}
