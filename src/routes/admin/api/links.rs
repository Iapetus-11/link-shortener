use chrono::{DateTime, Utc};
use poem::{
    Body, Route,
    http::StatusCode,
    web::{Data, Json},
};

use crate::{
    common::platform_auth::AuthedPlatform,
    db::links::{Link, create_link, get_link},
};

pub fn routes() -> Route {
    Route::new().at("", poem::post(post_create_link))
}

#[derive(Debug, thiserror::Error, serde::Serialize)]
#[cfg_attr(test, derive(serde::Deserialize))]
#[serde(tag = "error_type")]
enum PostCreateLinkError {
    #[error("slug is already in use for existing link")]
    SlugAlreadyUsed(LinkDetailsView),
}

#[derive(serde::Deserialize)]
#[cfg_attr(test, derive(serde::Serialize))]
struct PostCreateLinkRequest {
    slug: Option<String>,
    url: String,
    metadata: Option<serde_json::Value>,
}

#[derive(Debug, serde::Serialize)]
#[cfg_attr(test, derive(serde::Deserialize))]
struct LinkDetailsView {
    slug: String,
    url: String,
    metadata: Option<serde_json::Value>,
    created_at: DateTime<Utc>,
}

impl From<Link> for LinkDetailsView {
    fn from(value: Link) -> Self {
        LinkDetailsView {
            slug: value.slug,
            url: value.url,
            metadata: value.metadata,
            created_at: value.created_at,
        }
    }
}

#[poem::handler]
pub async fn post_create_link(
    db: Data<&sqlx::PgPool>,
    Json(create_request): Json<PostCreateLinkRequest>,
    AuthedPlatform(platform): AuthedPlatform,
) -> poem::Result<Json<LinkDetailsView>> {
    let mut db = db.acquire().await.unwrap();

    if let Some(custom_slug) = &create_request.slug {
        let link_for_slug = get_link(&mut db, custom_slug.as_str()).await.unwrap();

        if let Some(link_for_slug) = link_for_slug {
            return Err(poem::Error::from_response(
                poem::Response::builder()
                    .status(StatusCode::BAD_REQUEST)
                    .body(
                        Body::from_json(PostCreateLinkError::SlugAlreadyUsed(
                            LinkDetailsView::from(link_for_slug),
                        ))
                        .unwrap(),
                    ),
            ));
        }
    }

    let link = create_link(
        &mut db,
        &platform.id,
        create_request.slug,
        create_request.url,
        create_request.metadata,
    )
    .await
    .unwrap();

    Ok(Json(LinkDetailsView::from(link)))
}

#[cfg(test)]
mod tests {

    use serde_json::json;
    use sqlx::PgPool;

    use super::*;

    use crate::{
        common::testing::app::{api_test_client, platform_auth_header},
        db::platforms::create_platform,
    };

    #[sqlx::test]
    async fn test_post_create_link_with_custom_slug(db_pool: PgPool) {
        let mut db = db_pool.acquire().await.unwrap();

        let (api_key, platform) = create_platform(&mut db, "what are thooooooooseeee")
            .await
            .unwrap();

        let api = api_test_client(db_pool);
        let response = api
            .post("/admin/api/links/")
            .typed_header(platform_auth_header(&platform.id, &api_key))
            .body_json(&PostCreateLinkRequest {
                slug: Some("corn".to_string()),
                url: "https://cornhub.website/".to_string(),
                metadata: Some(json!({"something_id": 4206669})),
            })
            .send()
            .await;

        response.assert_status_is_ok();

        let link = get_link(&mut db, "corn").await.unwrap().unwrap();

        response
            .assert_json(LinkDetailsView::from(link.clone()))
            .await;

        assert_eq!(link.platform_id, platform.id);
        assert_eq!(link.slug, "corn");
        assert_eq!(link.url, "https://cornhub.website/");
    }

    #[sqlx::test]
    async fn test_post_create_link_with_autogenerated_slug(db_pool: PgPool) {
        let mut db = db_pool.acquire().await.unwrap();

        let (api_key, platform) = create_platform(&mut db, "what are thooooooooseeee")
            .await
            .unwrap();

        let api = api_test_client(db_pool);
        let response = api
            .post("/admin/api/links/")
            .typed_header(platform_auth_header(&platform.id, &api_key))
            .body_json(&PostCreateLinkRequest {
                slug: None,
                url: "https://iapetus11.me/".to_string(),
                metadata: Some(json!({"something_id": 4206669})),
            })
            .send()
            .await;

        response.assert_status_is_ok();

        let link = sqlx::query_as!(Link, "SELECT * FROM links")
            .fetch_one(&mut *db)
            .await
            .unwrap();

        response
            .assert_json(LinkDetailsView::from(link.clone()))
            .await;

        assert_eq!(link.platform_id, platform.id);
        assert_eq!(link.slug.len(), 7);
        assert_eq!(link.url, "https://iapetus11.me/");
    }
}
